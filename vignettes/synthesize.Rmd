---
title: "Synthesize"
author: "Johan Sebastian Ohlendorff"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: ReferencesSynthesize.bib
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction

This vignette demonstrates how the function synthesize can be used to make an estimated lava object [@lava, see the next ] based on a formula in R. This can then be used to simulate data that should be similar to the data that we used to estimate the lava object with. There are 3 kinds of responses that can be used in the synthesize object:

- A survival-type response, i.e. either a response of the form `Surv(time,event)` or `Hist(time, event)`.
- A categorical response (for now only binary responses are supported corresponding to logistic regression).
- A normal/gaussian response. 

We first give a mathematical specification of the model assumed for the data:

### Introduction to the model
Assume first that we are not dealing with survival data. For a general input formula `y ~ x1 + ... + xk`, with `recursive = FALSE`, we assume the following model for the data $(Y_i,X_{1i},\dots, X_{ki})_{i=1, \dots n}$ (the observations are assumed iid). The response variable $Y$ is assumed to have a linear predictor $\eta ^T \bf{X}$ (either in the case of a logistic regression model or a linear model). The covariates $X_i$ are assumed to each have their own distribution, depending on the type of variable that they are. Continuous variables variables are assumed to be gaussian, i.e. if the $j$'th covariate is continuous then $X_j \sim N(\mu_j, \sigma^2_j)$ - with categorical/binary variables a similar assumption is made.

In the case of survival outcome data, we change the above setup to the data $(T_i, \Delta_i,X_{1i},\dots, X_{ki})_{i=1, \dots n}$ (this is assumed to be iid) where $T_i$ is the right-censored lifetime, $\Delta_i$ is the indicator telling us whether $T_i$ is uncensored or censored. Then the model is that the uncensored lifetime and censorship times follow a Weibull model (this is needed in order to calculate the censored lifetime and indicator function and in order to simulate) with the same linear predictor as before. The covariates have also the same assumption as before. With competetive risks, a similar setup is made to this one.

With `recursive = TRUE`, we allow a type of structural equation models that states that we should also include the relationships (indicating the corresponding formulas in R)
\begin{align*}
X_1 &\sim X_2 + \dots + X_k \\
X_2 &\sim X_3 + \dots + X_k \\
... \\
X_{k-1} &\sim X_k \\
\end{align*}

Synthesize then estimates these estimates by maximum-likelihood estimation. We consider a few examples of our function. We first consider an example of the case where the response is a survival-type response. 

## Survival repsonse
We consider the survival case and load the PBC dataset and remove missing data:
```{r}
library(riskRegression)
library(survival)
library(lava)
head(pbc)
pbc <- na.omit(pbc)
```
We consider the variables `time` meaning the censored lifetime, `status` indicating whether the person died from the disease, survived (or something other entirely) and the measurement of bilirubin in the patient, and of protime in the patient.

There are two kinds of survival responses we can consider; one with competing risks outcome and one without. We first consider how to use synthesize normal survival outcome, but the other case is the same; we just don't use the line below. In this case we need to make the event variable binary, i.e.
```{r}
pbc$event <- 1*(pbc$status!=0)
```
Now we can synthesize a lava object:
```{r, warning=FALSE}
ms <- synthesize(Hist(time,event)~log(bili)+log(protime)+edema+sex+age,data=pbc)
ms
```


Here we look at the model specified, stating that the regression of uncensored lifetime of a person and censorship time is given by our Weibull assumption with regression on the covariates logprotime, logbilirubin, edema, age and sex, and that that the right censored time and indicator functions are calculated directly from these, and that the covariates have separately either the normal, categorical or binary distributions. Note that it is possible to specify how many unique values a variable can have to be considered either categorical or normal with `max.levels` (if not specified, it is 10). We can also look at the estimated parameters of this model by using `summary`:
```{r}
summary(ms)
```
which can be found under regression parameters. Let us consider a basic use case scenario, where we simulate:
```{r, warnings = FALSE}
set.seed(15)
d <- sim(ms,10000)
fit <- coxph(Surv(time,event)~log(bili)+log(protime)+factor(edema)+sex+age,data=pbc)
fit.s <- coxph(Surv(time,event)~log(bili)+log(protime)+edema+sex+age,data=d)
cbind(coef(fit),coef(fit.s))
```
First we simulate from our estimated model, then we fit a corresponding model to the data and the simulated data. Hopefully the numbers between the 2 columns should be very similar.

### Now with recursion

If we specify that we want to have recursion then:
```{r,warning=FALSE}
ms.rec <- synthesize(Hist(time,event)~log(bili)+log(protime)+sex+age+edema,recursive = TRUE, data=pbc)
ms.rec
```
Here we see that `logbili ~ logprotime + sex + age + edema, logprotime ~ sex+age+edema, sex~age+edema,age~edema` as should be specified. We could simulate again:
```{r}
set.seed(15)
d <- sim(ms.rec,10000)
fit <- coxph(Surv(time,event)~log(bili)+log(protime)+factor(edema)+sex+age,data=pbc)
fit.s <- coxph(Surv(time,event)~log(bili)+log(protime)+edema+sex+age,data=d)
cbind(coef(fit),coef(fit.s))
```

## A linear/logistic regression model
To make a simple linear regression model (the dataset `cars` is a included in R), we do:
```{r,include=FALSE}
data(cars)
m.cars <- synthesize(dist ~ speed, max.levels = 2, data=cars)
summary(m.cars)
```
The cars dataset consists of a number of observations of the speed of cars and their stopping distances. Checking that the model makes sense is another matter, and we will not consider it here. Finally for a binary response, you do the same as above.

## References
